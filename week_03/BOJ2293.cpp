// [BOJ2293] 동전 1 / 골드 4 / DP / 0 ms / 2060 KB

/*
    문제 입,출력
        n       :       ~100                int
        k       :       ~10'000             int

        s[n+@]  :                           int
        d[k+@]  :                           int     (경우의 수는 2^31 보다 작다는 조건)

        
    문제 방향

        테이블 정의
            d[i]    :    i원 일 때 경우의 수 
        점화식 정의
            d[i] = d[i] + d[i - s[j]]   (단, i >= s[j])
        초기식 정의
            d[0] = 1        (동전 자기 자신)


        예를 들면,

        초기    :   [1,0,0,0,0,0,0,0,0,0,0]
            1원 짜리 경우의 수를 찾는다면
        1원 처리후: [1,1,1,1,1,1,1,1,1,1,1]

        2원 처리후: [1,1,2,2,3,3,4,4,5,5,6]

        5원 처리후: [1,1,2,2,3,4,5,6,7,8,10]
            
*/

#include<bits/stdc++.h>
using namespace std;

int n,k;
int s[101], d[10'001];

int main(void){
    cin.tie(0);
    ios::sync_with_stdio(0);


    cin >> n >> k ;
    for(int i = 1 ; i <= n ; i ++ ) cin >> s[i];

    d[0] = 1;       //초기식 정의 (동전 자기 자신)

    for(int i = 1 ; i <=n; i ++){           // 모든 동전 순서대로 ex) 1, 2, 5 
        for(int j = s[i] ; j <= k ;  j++){  // k 도달 까지 
            d[j] += d[j - s[i]];            // 이전 경우의 수 더하기
        }
    }

    cout << d[k] ;
    
    
}
